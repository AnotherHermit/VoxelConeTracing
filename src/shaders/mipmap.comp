///////////////////////////////////////
//
//	Computer Graphics TSBK03
//	Conrad Wahlén - conwa099
//
///////////////////////////////////////

#version 430

layout(local_size_x = 64) in;

uniform uint currentLevel;

uniform layout(R32UI) uimage3D voxelData;
uniform layout(R32UI) uimage3D voxelDataNextLevel;

struct SceneParams {
	mat4 MTOmatrix[3];
	mat4 MTWmatrix;
	uint voxelDraw;
	uint view;
	uint voxelRes;
	uint voxelLayer;
	uint numMipLevels;
	uint mipLevel;
};

layout (std140, binding = 1) uniform SceneBuffer {
	SceneParams scene;
};

struct DrawElementsIndirectCommand {
	uint vertexCount;
	uint instanceCount;
	uint firstVertex;
	uint baseVertex;
	uint baseInstance;
};

layout(std430, binding = 0) buffer DrawCmdBuffer {
	DrawElementsIndirectCommand drawCmd[10];
};

struct ComputeIndirectCommand {
	uint workGroupSizeX;
	uint workGroupSizeY;
	uint workGroupSizeZ;
};

layout(std430, binding = 1) buffer ComputeCmdBuffer {
	ComputeIndirectCommand compCmd[10];
};

layout(std430, binding = 2) buffer SparseBuffer {
	uint sparseList[];
};

uint packARGB8(uvec4 input) {
	uint result = 0;

	result |= (input.a & 0xFF) << 24;
	result |= (input.r & 0xFF) << 16;
	result |= (input.g & 0xFF) << 8;
	result |= (input.b & 0xFF);

	return result;
}

uvec4 unpackARGB8(uint input) {
	uvec4 outVec;
	
	// Put a first to improve max operation but it should not be very noticable
	outVec.a = (input & 0xFF000000) >> 24;
	outVec.r = (input & 0x00FF0000) >> 16;
	outVec.g = (input & 0x0000FF00) >> 8;
	outVec.b = (input & 0x000000FF);

	return outVec;
}

uint packRG11B10(uvec3 input) {
	uint result = 0;

	result |= (input.r & 0x7FF) << 21;
	result |= (input.g & 0x7FF) << 10;
	result |= (input.b & 0x3FF);

	return result;
}

uvec3 unpackRG11B10(uint input) {
	uvec3 outVec;

	outVec.r = (input & 0xFFE00000) >> 21;
	outVec.g = (input & 0x001FFC00) >> 10;
	outVec.b = (input & 0x000003FF);

	return outVec;
}

void main(void)
{	
	uint currentVoxel = gl_GlobalInvocationID.x;
	uint voxelCount = drawCmd[currentLevel].instanceCount;

	if(currentVoxel < voxelCount) {
		uint currentOffset = drawCmd[currentLevel].baseInstance;
		uint voxelPos = currentVoxel + currentOffset;
		uvec3 voxelCoord = unpackRG11B10(sparseList[voxelPos]);

		uvec4 color = unpackARGB8(imageLoad(voxelData, ivec3(voxelCoord)).r);
		vec4 fColor = vec4(color) / float(color.a);
		color = uvec4(fColor * 31.0f);

		uint nextLevel = currentLevel + 1;
		uint nextOffset = drawCmd[nextLevel].baseInstance;
		uvec3 nextVoxelCoord = voxelCoord >> 1;

		uint prevColor = imageAtomicAdd(voxelDataNextLevel, ivec3(nextVoxelCoord), packARGB8(color));

		// Check if this voxel was empty before
		if(prevColor == 0) {
			// Write to number of voxels list
			uint nextIndex = atomicAdd(drawCmd[nextLevel].instanceCount, 1);

			// Calculate and store number of workgroups needed
			uint compWorkGroups = ((nextIndex + 1) >> 6) + 1; // 6 = log2(workGroupSize = 64)
			atomicMax(compCmd[nextLevel].workGroupSizeX, compWorkGroups);

			// Write to position buffer
			sparseList[nextIndex + nextOffset] = packRG11B10(uvec3(nextVoxelCoord));
		}
	}
}

